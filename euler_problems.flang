# flang - a functional language
#  - Euler problems ( https://projecteuler.net/archives ) solved in flang language to show its features
#  - flang is designed to solve real world problems.
#  - These are also unit tests for flang
#    Correct results are expected each and every time!
#  - This document works as a style guide for flang as well.
#  - See README more about flang and its design philosophy
# language: flang ( v. 0.83 )
# author: mystikkogames ( mystikkogames@protonmail.com )

( function :euler_1 ( ) :
    ( $sum 0 = )
    ( $i 1 = )
    ( loop ( $i 1000 < ) :
        ( if ( $i 5 % 0 == $i 3 % 0 == or ) : 
        	( $sum $i += ) 
        )
        ( $i ++ )
    )
    ( $sum ) 
)

( function :euler_2 ( ) : 
	( $sum 0 = )
	( $a 0 = )
	( $b 1 = )
	( $c 0 = )
	( loop ( $c 4000000 < ) : 
		( $c $a $b + = )	
		( $a $b = )
		( $b $c = )
		( if ( $c 2 % 0 == ) : 
            ( $sum $c += )
        )
	)
	( $sum ) # return here is optional since $sum is pushed to stack anyway
)

( function :euler_3 ( ) :   
	( $bignum 600851475143 = )
    ( $n 2 = )
    ( $biggest_factor 0 = )
	( loop ( $n $bignum 1 + < ) :
		( if ( $n *is_prime $bignum $n % 0 == and ) :
		    ( $bignum $bignum $n / = )
		    ( $biggest_factor $biggest_factor $n *max = )
        )
		( $n ++ )
    )
	( $biggest_factor )
)

( function :euler_4 ( ) :   
	( $start1 999 = )
	( $largest 0 = )
    ( loop ( $start1 100 > ) :
		( $start2 999 = )
        ( loop ( $start2 100 > ) :
            ( $res $start2 $start1 * = )
            ( if ( $res $largest < ) : ( break_loop ) )
            ( if ( $res 0 *char_at $res 5 *char_at == 
                $res 1 *char_at $res 4 *char_at == and 
                $res 2 *char_at $res 3 *char_at == and ) :
                ( $largest $res $largest *max = ) ) 
            ( $start2 -- )
        )
        ( $start1 -- )    
    )
    ( $largest )
)

( function :euler_5 ( ) :   
	( $n 0 = )
    # because non-primes are multiples of primes: 18=2*3*3 / 20=2*2*5 ...
    ( $step 2 3 5 7 11 13 17 * * * * * * = ) 
    ( loop ( 1 ) :
        ( $n $step += )
        ( $remainder 0 = )
        ( $i 2 = )
        ( loop ( $i 22 < ) :
            ( if  ( $n $i % 0 != ) : 
                ( $remainder 1 = )
                ( break_loop )
            )
            ( $i ++ )
        )
        ( if ( $remainder 0 == ) : 
        	( $n ) 
        	( return ) 
        ) 
    )
)

# brute force saves the day!
( function :euler_6 ( ) :   
	( $sum_of_squares 0 = )
	( $squares_of_sum 0 = )
    ( $i 1 = )
    ( loop ( $i 101 < ) :
	    ( $sum_of_squares $i $i * += )
	    ( $squares_of_sum $i += )
        ( $i ++ )
    )
    ( $squares_of_sum $squares_of_sum $squares_of_sum * =  )
    ( $squares_of_sum $sum_of_squares - ) 
)

( function :euler_7 ( ) :   	
	( 10000 *prime_nth ) # shame on me...
)

( function :euler_8 ( ) :   
    ( $data "data.json" *read_file =  ) 
    ( $str ".euler_8" $data *json_read *remove_whitespace = )
    ( $len $str *length = )
    ( $i 0 = )
    ( $maximum 0 = )
    ( loop ( $i 13 + $len < ) :
        ( $j 1 = )
        ( $product $str $i *char_at = )
        ( loop ( $j 13 < ) :
            ( $product $str $i $j + *char_at $product * = )
            ( $j ++ )
        )
        ( $maximum $product $maximum *max = )
        ( $i ++ )
    )
	( $maximum )
)

( function :euler_9 ( ) :   
    ( $a 1 = )
    ( loop ( $a 1000 < ) :
        ( $b $a 1 + = )
        ( loop ( $b 1000 < ) :
                ( $sum $a $a * $b $b * + = )
                ( $c 1000 $a $b + - = )
                ( if ( $c $b > $c *pow2 $sum == and ) :
                	( 1000 $a $b + - $a $b * * ) 
                	( return )        
                )
            ( $b ++ )
        )
        ( $a ++ )
    )
    ( "Shouldn't se me!" ! )
)

# in brute force we trust!
( function :euler_10 ( ) :   
    ( $i 0 = )
    ( $sum 0 = )
    ( $prime 0 = )
    ( loop ( $prime 2000000 < ) :
        ( $sum $prime += )
        ( $prime $i *prime_nth = ) 
        ( $i ++ )
    )
    ( $sum ) # return
)

( function :euler_11 ( ) :   
    ( $data "data.json" *read_file =  ) 
    ( $str ".euler_11" $data *json_read *remove_whitespace = )
    ( $x 0 = )
    ( $maximum 0 = )
    ( loop ( $x 16 < ) :
        ( $y 0 = )  
        ( loop ( $y 16 < ) :
            ( $pnt $x 2 * $y 40 * + = )
            ( $product_x
                $str $pnt *char_at $str $pnt 1 + *char_at *join
                $str $pnt 2 + *char_at $str $pnt 3 + *char_at *join
                $str $pnt 4 + *char_at $str $pnt 5 + *char_at *join
                $str $pnt 6 + *char_at $str $pnt 7 + *char_at *join
                * * * = 
            )
            ( $product_y 
                $str $pnt *char_at $str $pnt 1 + *char_at *join
                $str $pnt 40 + *char_at $str $pnt 41 + *char_at *join
                $str $pnt 80 + *char_at $str $pnt 81 + *char_at *join
                $str $pnt 120 + *char_at $str $pnt 121 + *char_at *join
                * * * = 
            )
            ( $product_diagonal 
                $str $pnt *char_at $str $pnt 1 + *char_at *join
                $str $pnt 42 + *char_at $str $pnt 43 + *char_at *join
                $str $pnt 84 + *char_at $str $pnt 85 + *char_at *join
                $str $pnt 126 + *char_at $str $pnt 127 + *char_at *join
                * * * = 
            )
            ( $maximum $product_x $maximum *max = )
            ( $maximum $product_y $maximum *max = )
            ( $maximum $product_diagonal $maximum *max = )
            ( $y ++ ) 
        )
        ( $x ++ )
    )
    # this fucker goes the other way so I have a special case for it
    ( $x 4 = )
    ( loop ( $x 20 < ) :
        ( $y 0 = )  
        ( loop ( $y 16 < ) :
            ( $pnt $x 2 * $y 40 * + = )
            ( $product_diagonal 
                # a little bit of mental gymnaustic and your mind transforms 2D easily to 1D
                $str $pnt *char_at $str $pnt 1 + *char_at *join
                $str $pnt 38 + *char_at $str $pnt 39 + *char_at *join
                $str $pnt 76 + *char_at $str $pnt 77 + *char_at *join
                $str $pnt 114 + *char_at $str $pnt 115 + *char_at *join
                * * * = 
            )   
            ( $maximum $product_diagonal $maximum *max = )
            ( $y ++ ) 
        )
        ( $x ++ )
    )
    ( $maximum ) # return
)

# You could simply brute force this too
# The idea here is to factorize number to its primes then sum their factor
# 28 = 2 ^ (2) * 7 ^ (1)
# (2 + 1) * (1 + 1) = 6 components
# I didn't know this math trick
# Credits: http://codeforces.com/blog/entry/22317
( function :euler_12 ( ) :   
	( $i 0 = )
	( loop ( 1 ) :
		( $sum2 $i $i 1 + * 2 / *int = )
		( $sum $sum2 = )
		( $prime 0 *prime_nth = )
		( $k 0 = )
		( $count 1 = )
		# We can do this speedup since factorization primes are small
		# should verify propably
		( loop ( $prime $prime $prime * * $sum <= ) :
			( $factors 0 = )
			( $prime $k *prime_nth = )		
			( $sum3 $sum = )	
			( loop ( $sum3 $prime % 0 == ) :	
				( $sum3 $sum3 $prime / *int = )			
				( $factors ++ )
			)			
			( $k ++ )
			( $count $factors 1 + $count * = )		
		)	
		( if ( $count 500 > ) : 
			( $sum2 ) 
			( return ) 
		)
		( $i ++ )
    )
)

# Good old brute force in action
( function :euler_13 ( ) :
    ( $data "data.json" *read_file = ) 
    ( $bigdata ".euler_13" $data *json_read *remove_whitespace = )
    ( $x 49 = )
    ( $sum "" = )
    ( $leftover 0 = )
    ( loop ( $x 0 >= ) : 
        ( $y 0 = )
        ( loop ( $y 100 < ) :
            ( $leftover $bigdata $y 50 * $x + *char_at += )
            ( $y ++ )
        )
        ( $sum $leftover 10 % $sum  *join = )
        ( $leftover $leftover 10 / *int = )
        ( $x -- )
    )
    ( $sum $leftover $sum  *join = )
    ( $answer "" = )
    ( $len $sum *length = )
    ( $i 0 = )
    ( loop ( $i 10 < ) : 
        ( $answer $answer $sum $i *char_at *join = )
        ( $i ++ )
    )
    ( $answer )  
)

# 13 eulers # 17.506s
( function :main ( ) :
    ( *clock_start )
    ( :euler_1 233168 == *assert )
    ( :euler_2 4613732 == *assert )
    ( :euler_3 6857 == *assert )
    ( :euler_4 906609 == *assert )
    ( :euler_5 232792560 == *assert )
    ( :euler_6 25164150 == *assert )
    ( :euler_7 104743 == *assert )
    ( :euler_8 23514624000 == *assert ) 
    ( :euler_9 31875000 == *assert )
    ( :euler_10 142913828922 == *assert )
    ( :euler_11 70600674 == *assert )
    ( :euler_12 76576500 == *assert ) 
    ( :euler_13 5537376230 == *assert ) 
    ( "13 eulers # " *clock_diff 3 *precision *join "s" *join ! )
)

