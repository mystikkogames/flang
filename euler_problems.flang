# flang - a functional language
#  - Euler problems ( https://projecteuler.net/archives ) solved in 
#      flang - language to show its features
#  - These are also unit tests for flang
#  - Correct results are expected each and every time!
#  - This document works as a style guide for flang as well.
#  - See README more about flang and its design philosophy
# language: flang ( v. 0.86 )
# author: mystikkogames ( mystikkogames@protonmail.com )

( function :euler_1 ( ) :
    ( $sum 0 = )
    ( $i 1 = )
    ( loop ( $i 1000 < ) :
        ( if ( $i 5 % 0 == $i 3 % 0 == or ) : 
        	( $sum $i += ) 
        )
        ( $i ++ )
    )
    ( $sum ) 
)

( function :euler_2 ( ) : 
	( $sum 0 = )
	( $a 0 = )
	( $b 1 = )
	( $c 0 = )
	( loop ( $c 4000000 < ) : 
		( $c $a $b + = )	
		( $a $b = )
		( $b $c = )
		( if ( $c 2 % 0 == ) : 
            ( $sum $c += )
        )
	)
	( $sum ) # return here is optional since $sum is pushed to stack anyway
)

( function :euler_3 ( ) :   
	( $bignum 600851475143 = )
    ( $n 2 = )
    ( $biggest_factor 0 = )
	( loop ( $n $bignum 1 + < ) :
		( if ( $n *is_prime $bignum $n % 0 == and ) :
		    ( $bignum $n /= )
		    ( $biggest_factor $biggest_factor $n *max = )
        )
		( $n ++ )
    )
	( $biggest_factor )
)

( function :euler_4 ( ) :   
	( $start1 999 = )
	( $largest 0 = )
    ( loop ( $start1 100 > ) :
		( $start2 999 = )
        ( loop ( $start2 100 > ) :
            ( $res $start2 $start1 * = )
            ( if ( $res $largest < ) : ( break ) )
            ( if ( $res 0 *char_at $res 5 *char_at == 
                $res 1 *char_at $res 4 *char_at == and 
                $res 2 *char_at $res 3 *char_at == and ) :
                ( $largest $res $largest *max = ) ) 
            ( $start2 -- )
        )
        ( $start1 -- )    
    )
    ( $largest )
)

( function :euler_5 ( ) :   
	( $n 0 = )
    # because non-primes are multiples of primes: 18=2*3*3 / 20=2*2*5 ...
    ( $step 2 3 5 7 11 13 17 * * * * * * = ) 
    ( loop ( 1 ) :
        ( $n $step += )
        ( $remainder 0 = )
        ( $i 2 = )
        ( loop ( $i 22 < ) :
            ( if  ( $n $i % 0 != ) : 
                ( $remainder 1 = )
                ( break )
            )
            ( $i ++ )
        )
        ( if ( $remainder 0 == ) : 
        	( $n ) 
        	( return ) 
        ) 
    )
)

# brute force saves the day!
( function :euler_6 ( ) :   
	( $sum_of_squares 0 = )
	( $squares_of_sum 0 = )
    ( $i 1 = )
    ( loop ( $i 101 < ) :
	    ( $sum_of_squares $i $i * += )
	    ( $squares_of_sum $i += )
        ( $i ++ )
    )
    ( $squares_of_sum $squares_of_sum *= )
    ( $squares_of_sum $sum_of_squares - ) 
)

( function :euler_7 ( ) :   	
	( 10000 *prime_nth ) # shame on me...
)

( function :euler_8 ( ) :   
    ( $data "data.json" *read_file =  ) 
    ( $str ".euler_8" $data *json_read *remove_whitespace = )
    ( $len $str *length = )
    ( $i 0 = )
    ( $maximum 0 = )
    ( loop ( $i 13 + $len < ) :
        ( $j 1 = )
        ( $product $str $i *char_at = )
        ( loop ( $j 13 < ) :
            ( $product $str $i $j + *char_at $product * = )
            ( $j ++ )
        )
        ( $maximum $product $maximum *max = )
        ( $i ++ )
    )
	( $maximum )
)

( function :euler_9 ( ) :   
    ( $a 1 = )
    ( loop ( $a 1000 < ) :
        ( $b $a 1 + = )
        ( loop ( $b 1000 < ) :
                ( $sum $a $a * $b $b * + = )
                ( $c 1000 $a $b + - = )
                ( if ( $c $b > $c *pow2 $sum == and ) :
                	( 1000 $a $b + - $a $b * * ) 
                	( return )        
                )
            ( $b ++ )
        )
        ( $a ++ )
    )
    ( "Shouldn't se me!" *print )
)

# in brute force we trust!
( function :euler_10 ( ) :   
    ( $i 0 = )
    ( $sum 0 = )
    ( $prime 0 = )
    ( loop ( $prime 2000000 < ) :
        ( $sum $prime += )
        ( $prime $i *prime_nth = ) 
        ( $i ++ )
    )
    ( $sum ) # return
)

( function :euler_11 ( ) :   
    ( $data "data.json" *read_file =  ) 
    ( $str ".euler_11" $data *json_read *remove_whitespace = )
    ( $x 0 = )
    ( $maximum 0 = )
    ( loop ( $x 16 < ) :
        ( $y 0 = )  
        ( loop ( $y 16 < ) :
            ( $pnt $x 2 * $y 40 * + = )
            ( $product_x
                $str $pnt *char_at $str $pnt 1 + *char_at *join
                $str $pnt 2 + *char_at $str $pnt 3 + *char_at *join
                $str $pnt 4 + *char_at $str $pnt 5 + *char_at *join
                $str $pnt 6 + *char_at $str $pnt 7 + *char_at *join
                * * * = 
            )
            ( $product_y 
                $str $pnt *char_at $str $pnt 1 + *char_at *join
                $str $pnt 40 + *char_at $str $pnt 41 + *char_at *join
                $str $pnt 80 + *char_at $str $pnt 81 + *char_at *join
                $str $pnt 120 + *char_at $str $pnt 121 + *char_at *join
                * * * = 
            )
            ( $product_diagonal 
                $str $pnt *char_at $str $pnt 1 + *char_at *join
                $str $pnt 42 + *char_at $str $pnt 43 + *char_at *join
                $str $pnt 84 + *char_at $str $pnt 85 + *char_at *join
                $str $pnt 126 + *char_at $str $pnt 127 + *char_at *join
                * * * = 
            )
            ( $maximum $product_x $maximum *max = )
            ( $maximum $product_y $maximum *max = )
            ( $maximum $product_diagonal $maximum *max = )
            ( $y ++ ) 
        )
        ( $x ++ )
    )
    # this fucker goes the other way so I have a special case for it
    ( $x 4 = )
    ( loop ( $x 20 < ) :
        ( $y 0 = )  
        ( loop ( $y 16 < ) :
            ( $pnt $x 2 * $y 40 * + = )
            ( $product_diagonal 
                # a little bit of mental gymnaustic and your mind transforms 2D easily to 1D
                $str $pnt *char_at $str $pnt 1 + *char_at *join
                $str $pnt 38 + *char_at $str $pnt 39 + *char_at *join
                $str $pnt 76 + *char_at $str $pnt 77 + *char_at *join
                $str $pnt 114 + *char_at $str $pnt 115 + *char_at *join
                * * * = 
            )   
            ( $maximum $product_diagonal $maximum *max = )
            ( $y ++ ) 
        )
        ( $x ++ )
    )
    ( $maximum ) # return
)

# You could simply brute force this too
# The idea here is to factorize number to its primes then sum their factor
# 28 = 2 ^ (2) * 7 ^ (1)
# (2 + 1) * (1 + 1) = 6 components
# I didn't know this math trick
# Credits: http://codeforces.com/blog/entry/22317
( function :euler_12 ( ) :   
	( $i 0 = )
	( loop ( 1 ) :
		( $sum2 $i $i 1 + * 2 / *int = )
		( $sum $sum2 = )
		( $prime 0 *prime_nth = )
		( $k 0 = )
		( $count 1 = )
		# We can do this speedup since factorization primes are small
		# should verify propably
		( loop ( $prime $prime $prime * * $sum <= ) :
			( $factors 0 = )
			( $prime $k *prime_nth = )		
			( $sum3 $sum = )	
			( loop ( $sum3 $prime % 0 == ) :	
				( $sum3 $sum3 $prime / *int = )			
				( $factors ++ )
			)			
			( $k ++ )
			( $count $factors 1 + *= )		
		)	
		( if ( $count 500 > ) : 
			( $sum2 ) 
			( return ) 
		)
		( $i ++ )
    )
)

# Good old brute force in action
( function :euler_13 ( ) :
    ( $data "data.json" *read_file = ) 
    ( $bigdata ".euler_13" $data *json_read *remove_whitespace = )
    ( $x 49 = )
    ( $sum "" = )
    ( $leftover 0 = )
    ( loop ( $x 0 >= ) : 
        ( $y 0 = )
        ( loop ( $y 100 < ) :
            ( $leftover $bigdata $y 50 * $x + *char_at += )
            ( $y ++ )
        )
        ( $sum $leftover 10 % $sum  *join = )
        ( $leftover $leftover 10 / *int = )
        ( $x -- )
    )
    ( $sum $leftover $sum  *join = )
    ( $answer "" = )
    ( $len $sum *length = )
    ( $i 0 = )
    ( loop ( $i 10 < ) : 
        ( $answer $answer $sum $i *char_at *join = )
        ( $i ++ )
    )
    ( $answer )  
)

# This is pretty much the most optimum algorithm I came up with.
# Pretty slow but that's how the cookie crambles
( function :euler_14 ( ) :
    ( $best_i 0 = )
    ( $largest 0 = )
    ( $i 0 = )
   	# You could use flang's general array but 
   	# this needs speed so I use the shared array
   	# salong means (s)hared (a)rray of (long)s
   	( 1000000 *resize_salong )
   	( *reset_salong )
   	( 1 0 *set_salong )
    ( loop ( $i 1000000 < ) :
        ( $number $i = )
        ( $n 0 = )
        ( loop ( $number 1 > $number $i >= and ) :
        	( if ( $number 2 % 0 == ) : 
        		( $number $number 2 / *int = ) 
        	else : 
        		( $number $number 3 * 1 + = ) 
        	)
        	( $n ++ )
        )
        ( $n $number *get_salong += )
        ( $i $n *set_salong )
       	( if ( $n $largest > ) : 
       		( $largest $n = ) 
       		( $best_i $i = ) 
       	)
        ( $i ++ )
    )
    ( *free_salong ) # actually just shrinks the size...
    ( $best_i )  
)

# Propably useless to use globals here but 
# you can use it to walk through general size of arrays
# flang now supports recursive functions!
( function :euler_15 ( ) :
    ( $luke_the_gridwalker ( lambda ( $x $y ) :
	    ( if ( $x $$GRIDSIZE > $y $$GRIDSIZE > or ) : 
		    ( 0 ) 
		    ( return ) 
	    )	
	    # ie. "2x2" grid is actually 3 wide that's why we make x 1 longer!
	    ( $pnt $y $$GRIDSIZE 1 + * $x + = )	
	    ( $n $pnt *get_salong = )	
	    ( if ( $n 0 > ) : ( $n ) ( return ) )        
	    ( if ( $x $$GRIDSIZE == $y $$GRIDSIZE == and ) :
		    ( 1 )
		    ( return )
	    else : 
		    ( $tmp1 $x 1 + $y self = ) 
		    ( $tmp2 $x $y 1 + self = ) 		
		    ( $res $tmp1 $tmp2 + = )		
            ( $pnt $res *set_salong )        
            ( $res )
		    ( return )
	    )
    ) = )
   	( $$GRIDSIZE 20 = )
   	( 100000 *resize_salong )
   	( *reset_salong )   	
   	( 0 0 :$luke_the_gridwalker )
   	# ( *free_salong ) # no need to free this really
)

( function :euler_16 ( ) :
    ( $multiply_2 ( lambda ( $num ) : 
        ( $len $num *length = ) 
        ( $new "" = )
        ( $i $len 1 - = ) 
        ( $leftover 0 = ) 
        ( loop ( $i 0 >= ) : 
            ( $n $num $i *char_at = )
            ( $n $n 2 * $leftover + = )
            ( $leftover 0 = )
            ( if ( $n 9 > ) : ( $n 10 -= ) ( $leftover 1 = ) )
            ( $new $n $new *join = )
            ( $i -- ) 
        )
        ( if ( $leftover ) : ( $new $leftover $new *join = ) )
        ( $new )
    ) = )
    ( $num "2" = $i 1 = )    
    ( loop ( $i 1000 < ) : ( $num $num :$multiply_2 = ) ( $i ++ ) )
    ( $len $num *length = )
    ( $i 0 = )
    ( $sum 0 = )
    ( loop ( $i $len < ) : ( $sum $num $i *char_at += ) ( $i ++ ) )
    ( $sum )
)

( function :euler_17 ( ) :
    ( $num_words ( lambda ( $n ) : 
        ( if ( $n 1 == ) : ( "one" )  
        elif ( $n 2 == ) : ( "two" )  
        elif ( $n 3 == ) : ( "three" )  
        elif ( $n 4 == ) : ( "four" )  
        elif ( $n 5 == ) : ( "five" )  
        elif ( $n 6 == ) : ( "six" )  
        elif ( $n 7 == ) : ( "seven" )  
        elif ( $n 8 == ) : ( "eight" )  
        elif ( $n 9 == ) : ( "nine" )  
        elif ( $n 10 == ) : ( "ten" )  
        elif ( $n 11 == ) : ( "eleven" )  
        elif ( $n 12 == ) : ( "twelve" )  
        elif ( $n 13 == ) : ( "thirteen" )  
        elif ( $n 14 == ) : ( "fourteen" )  
        elif ( $n 15 == ) : ( "fifteen" )  
        elif ( $n 16 == ) : ( "sixteen" )  
        elif ( $n 17 == ) : ( "seventeen" )  
        elif ( $n 18 == ) : ( "eighteen" )  
        elif ( $n 19 == ) : ( "nineteen" )  
        elif ( $n 20 == ) : ( "twenty" )  
        elif ( $n 30 == ) : ( "thirty" )  
        elif ( $n 40 == ) : ( "forty" )  
        elif ( $n 50 == ) : ( "fifty" )  
        elif ( $n 60 == ) : ( "sixty" )  
        elif ( $n 70 == ) : ( "seventy" )
        elif ( $n 80 == ) : ( "eighty" ) 
        elif ( $n 90 == ) : ( "ninety" ) 
        else : ( "" )
    ) ) = )
    ( $num_to_words ( lambda ( $n $num_words ) :
        ( $res "" = )
        ( $len $n *length = ) 
        ( if ( $n *length 4 == ) : ( "onethousand" ) ( return ) )
        ( if ( $n *length 3 == ) : 
            ( $tmp $n 0 *char_at :$num_words = )
            ( $res $res $tmp *join "hundred" *join = ) 
            ( $n $n 1 3 *string_slice = ) 
            ( $n $n *int = )
            ( if ( $n *int ) : ( $res $res "and" *join = ) )
        )
        ( $n $n *int = ) # cleanup because we might have ugly 01 / 06 ...
        ( if ( $n *length 2 <= ) :
            ( if ( $n 21 < ) : 
            ( $res $res $n :$num_words *join = ) 
                ( $res ) 
                ( return ) 
            )
            ( $tmp $n $n 10 % - :$num_words = )
            ( $tmp2 $n 10 % :$num_words = )
            ( $res $tmp *join $tmp2 *join ) 
            ( return )
        )
    ) = )
    ( $i 1 = ) 
    ( $sum 0 = ) 
    ( loop ( $i 1000 <= ) : ( $sum $num_words $i :$num_to_words *length += ) ( $i ++ ) )
    ( $sum )
)

( function :euler_18 ( ) :
    ( $luke_the_trianglewalker ( lambda ( $x $y ) :
        ( if ( $y 15 >= ) :
            ( 0 )
            ( return ) 
        )
        ( $s "7595641747821835871020048247651901237503348802777307636799650428061670924141265683408070334148723347323716942953714465254391529"
            "75114701133287773177839681757917152381714914358502729486366046889536730731669874031046298272309709873933853600423" *join = )
        # 0.5 * ( n + 1 ) * ( n )
        # 0 => 0 / 1 => 1 / 2 => 3 / 3 => 6 / 4 => 10 / ...
        ( $start 0.5 $y 1 + $y * * *int 2 * = )
        ( $max 0 = )
        ( $pnt $start $x 2 * + = )
        ( $num $s $pnt *char_at = )
        ( $num $num $s $pnt 1 + *char_at *join = )
        ( $num $num *int = )
        ( $tmp $pnt *get_salong = )	
        ( if ( $tmp  ) : 
             ( $max $max $tmp $num + *max = )
            else : 
            ( $res1 $y 1 + $x self = )
            ( $res2 $y 1 + $x 1 + self = )
            ( $res $res1 $res2 *max = )
            ( $pnt $res *set_salong ) 
            ( $max $max $res $num + *max = )
        )
        ( $max )
    ) = )
   	( 1000000 *resize_salong )
   	( *reset_salong )
    ( 0 0 :$luke_the_trianglewalker ) 
)

# Euler unit tests # 168.204s
( function :main ( ) :
    ( *clock_start )
    ( :euler_1 233168 == *assert )
    ( :euler_2 4613732 == *assert )
    ( :euler_3 6857 == *assert )
    ( :euler_4 906609 == *assert )
    ( :euler_5 232792560 == *assert )
    ( :euler_6 25164150 == *assert )
    ( :euler_7 104743 == *assert )
    ( :euler_8 23514624000 == *assert ) 
    ( :euler_9 31875000 == *assert )
    ( :euler_10 142913828922 == *assert )
    ( :euler_11 70600674 == *assert )
    ( :euler_12 76576500 == *assert ) 
    ( :euler_13 5537376230 == *assert ) 
    ( :euler_14 837799 == *assert ) 
    ( :euler_15 137846528820 == *assert )
    ( :euler_16 1366 == *assert )
    ( :euler_17 21124 == *assert )
    ( :euler_18 1074 == *assert )
    ( "Euler unit tests # " *clock_diff 3 *precision *join "s" *join *print )
)

